//
// BMP Suite (2012 rewrite)
// Copyright (C) 2012-2016 Jason Summers
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//
// Image files generated by this program are in the public domain.
//

#ifdef _WIN32
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#ifdef _WIN32
#include <direct.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>

// #define SMALL_IMAGES

#define BMP_MAX_SIZE 100000

#define bmpovl_width 78
#define bmpovl_height 26
#define bmpovl_xpos 25
#define bmpovl_ypos 19

static const char *bmpovl[] = {
 "11111111111111111111.......11....................11...11111111111111111111....",
 "1111111111111111111111.....111..................111...1111111111111111111111..",
 "11222222222222222222111....1111................1111...11222222222222222222111.",
 "112222222222222222222111...11211..............11211...112222222222222222222111",
 "112211111111111111122211...112211............112211...112211111111111111122211",
 "112211111111111111112211...1122211..........1122211...112211111111111111112211",
 "112211...........1112211...11222211........11222211...112211...........1112211",
 "112211............112211...112212211......112212211...112211............112211",
 "112211............112211...1122112211....1122112211...112211............112211",
 "112211...........1112211...11221112211..11221112211...112211...........1112211",
 "11221111111111111112211....112211112211112211112211...112211111111111111112211",
 "1122111111111111112211.....112211.1122112211.112211...112211111111111111122211",
 "112222222222222222211......112211..11222211..112211...112222222222222222222111",
 "112222222222222222211......112211...112211...112211...11222222222222222222111.",
 "1122111111111111112211.....112211....1111....112211...1122111111111111111111..",
 "11221111111111111112211....112211.....11.....112211...11221111111111111111....",
 "112211...........1112211...112211............112211...112211..................",
 "112211............112211...112211............112211...112211..................",
 "112211............112211...112211............112211...112211..................",
 "112211...........1112211...112211............112211...112211..................",
 "112211111111111111112211...112211............112211...112211..................",
 "112211111111111111122211...112211............112211...112211..................",
 "112222222222222222222111...112211............112211...112211..................",
 "11222222222222222222111....112211............112211...112211..................",
 "1111111111111111111111.....111111............111111...111111..................",
 "11111111111111111111.......111111............111111...111111.................."
};

#define I_R 0
#define I_G 1
#define I_B 2
#define I_A 3

struct color_f {
	double s[4]; // [0]=R, [1]=G, [2]=B, [3]=A
};

struct color_i {
	unsigned int s[4]; // R, G, B, A
};

struct global_context {
	unsigned char *mem;
};

// Data specific to each image
struct context {
	const char *filename;
	unsigned char *mem;
	size_t mem_used;
	int bpp;
	int pal_entries;
	int clr_used;
	int headersize;
	int bitfieldssize;
	int palettesize;
	int extrabytessize;
	int bitsoffset; // Offset from beginning of file
	int bitssize;
	int profile_offset; // Offset from beginning of file
	int profile_size;
	int w, h;
	int rowsize;
	int xpelspermeter, ypelspermeter;
#define CMPR_RLE8 1
#define CMPR_RLE4 2
#define CMPR_JPEG 4
#define CMPR_PNG  5
#define BI_BITFIELDS      3
#define BI_ALPHABITFIELDS 6
	int compression;

	int pal_gs; // grayscale palette
	int pal_wb; // 2-color, palette[0] = white
	int pal_bg; // 2-color, blue & green
	int pal_p1; // 1-color
	unsigned int bf[4]; // bitfields for R, G, B, A. Used if bpp==16 or 32.
	unsigned int nbits[4];
	unsigned int bf_shift[4];

	// The dither codes tell how to quantize each sample.
	// -1 = default; 0 = no dithering; 1 = dithering
	int dither[4];

	int topdown;
	int embed_profile;
	int profile_to_embed;
	int swaprg;
	int link_profile;
	int fakealpha;
	int halfheight;
	int zero_biSizeImage;
	int bad_biSizeImage;
	int bad_bfSize;
	int bad_width;
	int bad_reallybig;
	int bad_bitcount;
	int bad_planes;
	int bad_palettesize;
	int bad_rle;
	int bad_rle_bis;
	int bad_rle_ter;
	int cut_rle;
	int bad_eof;
	int rletrns;
	int palette_reserve; // Reserve palette color #0
	int cbsize_flag;
	int trnstype; // Transparency type: 0=none, 1=binary, 2=full
};

static void set_int16(struct context *c, size_t offset, int v)
{
	c->mem[offset] = v&0xff;
	c->mem[offset+1] = (v>>8)&0xff;
}

static void set_int32(struct context *c, size_t offset, int v)
{
	c->mem[offset] = v&0xff;
	c->mem[offset+1] = (v>>8)&0xff;
	c->mem[offset+2] = (v>>16)&0xff;
	c->mem[offset+3] = (v>>24)&0xff;
}

static void set_uint32(struct context *c, size_t offset, unsigned int v)
{
	c->mem[offset] = v&0xff;
	c->mem[offset+1] = (v>>8)&0xff;
	c->mem[offset+2] = (v>>16)&0xff;
	c->mem[offset+3] = (v>>24)&0xff;
}

// Returns an int between 0 and (numcc-1), inclusive.
static int scale_to_int(double x, int numcc)
{
	int s;
#define BMPSUITE_EPSILON 0.0000001
	s = (int)(0.5+BMPSUITE_EPSILON+x*(numcc-1));
	if(s<0) s=0;
	if(s>numcc-1) s=numcc-1;
	return s;
}

static double srgb_to_linear(double v_srgb)
{
	if(v_srgb<=0.04045) {
		return v_srgb/12.92;
	}
	else {
		return pow( (v_srgb+0.055)/(1.055) , 2.4);
	}
}

static double linear_to_srgb(double v_linear)
{
	if(v_linear<=0.0031308) {
		return v_linear*12.92;
	}
	else {
		return 1.055*pow(v_linear, 1.0/2.4) - 0.055;
	}
}

static void get_pixel_color(struct context *c, int x1, int y1,
	struct color_f *clr)
{
	unsigned char t;
	int x, y;

#ifdef SMALL_IMAGES
	x = x1+21;
	y = y1+16;
#else
	x = x1;
	y = y1;
#endif

	if(x>=bmpovl_xpos && x<(bmpovl_xpos+bmpovl_width) &&
	   y>=bmpovl_ypos && y<(bmpovl_ypos+bmpovl_height))
	{
		t = bmpovl[y-bmpovl_ypos][x-bmpovl_xpos];
		if(t=='1') {
			clr->s[I_R] = 0.0; clr->s[I_G] = 0.0; clr->s[I_B] = 0.0; clr->s[I_A] = 1.0;
			goto done;
		}
		else if(t=='2') {
			if(c->trnstype==2) { // alpha transparency
				// Make the inside of the overlay transparent, if possible.
				if( (y-bmpovl_ypos)<(bmpovl_height/2) ) {
					// Make the top half completely transparent ("transparent green").
					clr->s[I_R] = 0.0;  clr->s[I_G] = 1.0; clr->s[I_B] = 0.0; clr->s[I_A] = 0.0;
				}
				else {
					// Make the bottom half a red gradient from transparent to opaque.
					clr->s[I_R] = 1.0; clr->s[I_G] = 0.0; clr->s[I_B] = 0.0;
					clr->s[I_A] = 2*((double)(y-bmpovl_ypos)) /(bmpovl_height) -1.0;
				}
			}
			else if(c->trnstype==1) { // binary transparency
				clr->s[I_R] = 1.0; clr->s[I_G] = 1.0; clr->s[I_B] = 1.0; clr->s[I_A] = 0.0;
			}
			else {
				clr->s[I_R] = 1.0; clr->s[I_G] = 1.0; clr->s[I_B] = 1.0; clr->s[I_A] = 1.0;
			}
			goto done;
		}
	}

	clr->s[I_A] = 1.0;

	// Standard truecolor image
	if(x<32) {
		clr->s[I_R] = ((double)(63-y))/63.0;
		clr->s[I_G] = ((double)(x%32))/31.0;
		clr->s[I_B] = ((double)(x%32))/31.0;
	}
	else if(x<64) {
		clr->s[I_R] = ((double)(x%32))/31.0;
		clr->s[I_G] = ((double)(63-y))/63.0;
		clr->s[I_B] = ((double)(x%32))/31.0;
	}
	else if(x<96) {
		clr->s[I_R] = ((double)(x%32))/31.0;
		clr->s[I_G] = ((double)(x%32))/31.0;
		clr->s[I_B] = ((double)(63-y))/63.0;
	}
	else {
		clr->s[I_R] = ((double)(159-y))/255.0;
		clr->s[I_G] = ((double)(159-y))/255.0;
		clr->s[I_B] = ((double)(159-y + x%32))/255.0;
	}

done:
	if(c->fakealpha)
		clr->s[I_A] = 1.0 - ((double)y)/(c->h-1);
}

static int ordered_dither_lowlevel(double fraction, int x, int y)
{
	double threshold;
	static const float pattern[64] = {
		 0.5/64,48.5/64,12.5/64,60.5/64, 3.5/64,51.5/64,15.5/64,63.5/64,
		32.5/64,16.5/64,44.5/64,28.5/64,35.5/64,19.5/64,47.5/64,31.5/64,
		 8.5/64,56.5/64, 4.5/64,52.5/64,11.5/64,59.5/64, 7.5/64,55.5/64,
		40.5/64,24.5/64,36.5/64,20.5/64,43.5/64,27.5/64,39.5/64,23.5/64,
		 2.5/64,50.5/64,14.5/64,62.5/64, 1.5/64,49.5/64,13.5/64,61.5/64,
		34.5/64,18.5/64,46.5/64,30.5/64,33.5/64,17.5/64,45.5/64,29.5/64,
		10.5/64,58.5/64, 6.5/64,54.5/64, 9.5/64,57.5/64, 5.5/64,53.5/64,
		42.5/64,26.5/64,38.5/64,22.5/64,41.5/64,25.5/64,37.5/64,21.5/64
	 };

	threshold = pattern[(x%8) + 8*(y%8)];
	return (fraction >= threshold) ? 1 : 0;
}

// 'v' is on a scale from 0.0 to 1.0.
// numcc is the number of output color codes, e.g. 256. The result will be
// from 0 to (numcc-1).
// Not all combinations of flags are supported.
static int quantize(double v_to_1, int numcc, int x, int y,
	int dither, int from_srgb, int to_srgb)
{
	double v_to_1_linear;
	double v_to_1_targetcs;
	double v_to_maxcc;
	double floor_to_maxcc, ceil_to_maxcc;
	double floor_to_1, ceil_to_1;
	double floor_to_1_linear, ceil_to_1_linear;
	double fraction;
	int all_linear;
	int maxcc = numcc-1;

	if(dither<1 && !from_srgb && !to_srgb) {
		return scale_to_int(v_to_1, numcc);
	}

	all_linear = (!from_srgb && !to_srgb);

	if(all_linear)
		v_to_1_targetcs = v_to_1;
	else
		v_to_1_targetcs = from_srgb ? v_to_1 : linear_to_srgb(v_to_1);

	v_to_maxcc = v_to_1_targetcs*maxcc;
	floor_to_maxcc = floor(v_to_maxcc);
	if(floor_to_maxcc>=(double)maxcc) return maxcc;
	ceil_to_maxcc = floor_to_maxcc+1.0;

	// The two possible values to return are floor_to_maxcc and ceil_to_maxcc.
	// v_to_maxcc's brightness is some fraction of the way between
	// floor_to_maxcc's brightness and ceil_to_maxcc's brightness, and we need
	// to calculate that fraction. To do that, convert everything to a linear
	// colorspace.

	floor_to_1 = floor_to_maxcc/maxcc;
	ceil_to_1 = ceil_to_maxcc/maxcc;
	if(all_linear)
		floor_to_1_linear = floor_to_1;
	else
		floor_to_1_linear = srgb_to_linear(floor_to_1);
	v_to_1_linear = from_srgb ? srgb_to_linear(v_to_1) : v_to_1;
	if(all_linear)
		ceil_to_1_linear = ceil_to_1;
	else
		ceil_to_1_linear = srgb_to_linear(ceil_to_1);

	fraction = (v_to_1_linear-floor_to_1_linear)/(ceil_to_1_linear-floor_to_1_linear);

	if(ordered_dither_lowlevel(fraction,x,y))
		return (int)ceil_to_maxcc;
	else
		return (int)floor_to_maxcc;
}

static double srgb_to_linear_gray(const struct color_f *clr)
{
	return srgb_to_linear(clr->s[I_R])*0.212655 +
		srgb_to_linear(clr->s[I_G])*0.715158 +
		srgb_to_linear(clr->s[I_B])*0.072187;
}

static void set_pixel(struct context *c, int x, int y,
  const struct color_f *clr)
{
	struct color_i qclr;
	int tmp1, tmp2, tmp3;
	int p;
	int z;
	size_t row_offs;
	size_t offs;
	double tmpd;
	unsigned int u;

	if(c->topdown)
		row_offs = y*c->rowsize;
	else
		row_offs = (c->h-y-1)*c->rowsize;

	if(c->bpp==32) {
		offs = row_offs + 4*x;
		for(z=0; z<3; z++) {
			qclr.s[z] = quantize(clr->s[z], 1<<c->nbits[z], x, y, 0, 0, 0);
		}
		if(c->nbits[I_A])
			qclr.s[I_A] = quantize(clr->s[I_A], 1<<c->nbits[I_A], x, y, c->dither[I_A], 0, 0);

		u = (qclr.s[I_R]<<c->bf_shift[I_R]) | (qclr.s[I_G]<<c->bf_shift[I_G]) | (qclr.s[I_B]<<c->bf_shift[I_B]);
		if(c->nbits[I_A]) u |= qclr.s[I_A]<<c->bf_shift[I_A];
		c->mem[c->bitsoffset+offs+0] = (unsigned char)(u&0xff);
		c->mem[c->bitsoffset+offs+1] = (unsigned char)((u>>8)&0xff);
		c->mem[c->bitsoffset+offs+2] = (unsigned char)((u>>16)&0xff);
		c->mem[c->bitsoffset+offs+3] = (unsigned char)((u>>24)&0xff);
	}
	else if(c->bpp==24) {
		offs = row_offs + 3*x;
		for(z=0; z<3; z++) {
			qclr.s[z] = quantize(clr->s[z], 256, x, y, 0, 0, 0);
		}
		if(c->swaprg) {
			u = qclr.s[I_R]; qclr.s[I_R] = qclr.s[I_G]; qclr.s[I_G] = u;
		}
		c->mem[c->bitsoffset+offs+0] = (unsigned char)qclr.s[I_B];
		c->mem[c->bitsoffset+offs+1] = (unsigned char)qclr.s[I_G];
		c->mem[c->bitsoffset+offs+2] = (unsigned char)qclr.s[I_R];
	}
	else if(c->bpp==16) {
		offs = row_offs + 2*x;
		for(z=0; z<3; z++) {
			if(c->dither[z]==1)
				qclr.s[z] = quantize(clr->s[z], 1<<c->nbits[z], x, y, 1, 1, 1);
			else
				qclr.s[z] = quantize(clr->s[z], 1<<c->nbits[z], x, y, 0, 0, 0);
		}
		if(c->nbits[I_A])
			qclr.s[I_A] = quantize(clr->s[I_A], 1<<c->nbits[I_A], x, y, c->dither[I_A], 0, 0);

		u = (qclr.s[I_R]<<c->bf_shift[I_R]) | (qclr.s[I_G]<<c->bf_shift[I_G]) | (qclr.s[I_B]<<c->bf_shift[I_B]);
		if(c->nbits[I_A]) u |= qclr.s[I_A]<<c->bf_shift[I_A];
		c->mem[c->bitsoffset+offs+0] = (unsigned char)(u&0xff);
		c->mem[c->bitsoffset+offs+1] = (unsigned char)((u>>8)&0xff);
	}
	else if(c->bpp==8) {
		offs = row_offs + x;
		if (c->pal_gs) {
			tmpd = srgb_to_linear_gray(clr);
			p = quantize(tmpd, c->pal_entries - c->palette_reserve, x, y, 1, 0, 1);

			if(c->palette_reserve) {
				if(p<c->pal_entries) p++;
			}
		}
		else {
			tmp1 = quantize(clr->s[I_R], 6, x, y, 1, 1, 1);
			tmp2 = quantize(clr->s[I_G], 7, x, y, 1, 1, 1);
			tmp3 = quantize(clr->s[I_B], 6, x, y, 1, 1, 1);
			p = tmp1 + tmp2*6 + tmp3*42;
			if(c->palette_reserve) {
				if(p<255) p++;
			}
		}
		c->mem[c->bitsoffset+offs] = p;
	}
	else if(c->bpp==4) {
		offs = row_offs + x/2;
		if (c->pal_gs) {
			tmpd = srgb_to_linear_gray(clr);
			p = quantize(tmpd, c->pal_entries - c->palette_reserve, x, y, 1, 0, 1);

			if(c->palette_reserve) {
				if(p<c->pal_entries) p++;
			}
		}
		else {
			tmp1 = quantize(clr->s[I_R], 2, x, y, 1, 1, 1);
			tmp2 = quantize(clr->s[I_G], 3, x, y, 1, 1, 1);
			tmp3 = quantize(clr->s[I_B], 2, x, y, 1, 1, 1);
			p = tmp1 + tmp2*2 + tmp3*6;
		}
		if(x%2)
			c->mem[c->bitsoffset+offs] |= p;
		else
			c->mem[c->bitsoffset+offs] |= p<<4;
	}
	else if(c->bpp==2) {
		offs = row_offs + x/4;
		tmpd = srgb_to_linear_gray(clr);
		tmp1 = quantize(tmpd, 4, x, y, 1, 0, 1);
		c->mem[c->bitsoffset+offs] |= tmp1<<(2*(3-x%4));
	}
	else if(c->bpp==1) {
		offs = row_offs + x/8;
		tmpd = srgb_to_linear_gray(clr);
		tmp1 = quantize(tmpd, 2, x, y, 1, 0, 1);
		if(c->pal_wb) tmp1 = 1-tmp1; // Palette starts with white, so invert the colors.
		if(c->pal_p1) tmp1 = 0;
		if(tmp1) {
			c->mem[c->bitsoffset+offs] |= 1<<(7-x%8);
		}
	}
}

static void calc_rle_run_lens(struct context *c, const unsigned char *row,
    int *run_lens, int pixels_per_row)
{
	int i,k,n;

	for(i=0;i<pixels_per_row;i++) {
		n=0;
		for(k=i;k<pixels_per_row;k++) {
			if(n>=255) break;

			if(c->rletrns && row[k]==0) {
				// A "transparent" pixel.
				if(k-i==0) { n++; continue; } // start of a transparent run
				if(row[k-1]==0) { n++; continue; } // continuing a transparent run;
				break; // transparent pixel stops a nontransparent run.
			}

			if(c->rletrns && k-i>=1) {
				if(row[k]!=0 && row[k-1]==0) {
					// nontransparent pixel stops a transparent run.
					break;
				}
			}

			if(c->compression==CMPR_RLE4 && k-i<=1) { n++; continue; } // (RLE4) First two pixels can always be part of the run
			if(c->compression==CMPR_RLE8 && k-i<=0) { n++; continue; } // (RLE8) First pixels can always be part of the run
			if(c->compression==CMPR_RLE4 && row[k]==row[k-2]) { n++; continue; }
			if(c->compression==CMPR_RLE8 && row[k]==row[k-1]) { n++; continue; }
			break;
		}
		run_lens[i] = n;
	}
}

// Note: This is not a particularly good BMP RLE compression algorithm.
// I don't recommend copying it.
static int write_bits_rle(struct context *c)
{
	size_t curpos; // where in c->mem to write to next
	size_t rowpos;
	int pixels_per_row;
	unsigned char *row = NULL;
	int *run_lens = NULL;
	int i,j;
	int j_logical;
	int k;
	int tmp1, tmp2, tmp3;
	struct color_f clr;
	int unc_len;
	int unc_len_padded;
	int thresh;
	int retval = 0;

	curpos = c->bitsoffset;
	pixels_per_row = c->w;
	row = malloc(pixels_per_row);
	if(!row) goto done;
	run_lens = malloc(sizeof(int)*pixels_per_row);
	if(!run_lens) goto done;
	thresh = c->compression==CMPR_RLE4 ? 5 : 4;

	for(j=0;j< (c->cut_rle ? c->h - 5 : c->h);j++) {
		j_logical = c->topdown ? j : c->h-1-j;

		// Temporarily store the palette indices in row[]
		for(i=0;i<c->w;i++) {
			get_pixel_color(c,i,j_logical, &clr);

			if(c->compression==CMPR_RLE4) {
				tmp1 = quantize(clr.s[I_R],2,i,j_logical,1,1,1);
				tmp2 = quantize(clr.s[I_G],3,i,j_logical,1,1,1);
				tmp3 = quantize(clr.s[I_B],2,i,j_logical,1,1,1);
				row[i] = c->palette_reserve + tmp1 + tmp2*2 + tmp3*6;
			}
			else {
				tmp1 = quantize(clr.s[I_R],6,i,j_logical,1,1,1);
				tmp2 = quantize(clr.s[I_G],7,i,j_logical,1,1,1);
				tmp3 = quantize(clr.s[I_B],6,i,j_logical,1,1,1);
				row[i] = c->palette_reserve + tmp1 + tmp2*6 + tmp3*42;
			}
			if(c->rletrns && clr.s[I_A]<0.5) {
				row[i] = 0;
			}
		}

		// Figure out the largest possible run length for each starting pixel.
		calc_rle_run_lens(c,row,run_lens,pixels_per_row);

		rowpos = 0; // index into row[]

		while((int)rowpos < pixels_per_row) {

			if(c->rletrns && row[rowpos]==0) { // transparent pixel
				c->mem[curpos++] = 0;
				c->mem[curpos++] = 2;
				c->mem[curpos++] = run_lens[rowpos] + (unsigned char)(c->bad_rle?5:0) + (unsigned char)(c->bad_rle_bis?127:0); // x delta
				c->mem[curpos++] = (unsigned char)(c->bad_rle?2:0) + (unsigned char)(c->bad_rle_ter?1:0); // y delta
				rowpos += run_lens[rowpos];
				continue;
			}
			if (c->cut_rle && ((int)rowpos > (pixels_per_row/2))) {
				if ((j & 3) == 0) {
					break;
				}
			}

			if(run_lens[rowpos]<thresh) {
				// Consider writing an uncompressed segment

				// Find next run that's 'thresh' or larger
				for(k=rowpos;k<pixels_per_row;k++) {
					if(c->rletrns && row[k]==0) {  break; } // Also have to stop at a transparent pixel
					if(run_lens[k]>=thresh) { break; }
				}
				// If there's at least 3(?) pixels before it, write an uncompressed segment.
				if(k != -1 && k-rowpos >= 3) {
					unc_len = k-rowpos;

					if(c->compression==CMPR_RLE4)
						unc_len_padded = unc_len + (3-(unc_len+3)%4);
					else
						unc_len_padded = unc_len + (unc_len%2);

					c->mem[curpos++] = 0;
					c->mem[curpos++] = unc_len;
					for(i=0;i<unc_len_padded;i++) {
						unsigned char v;
						if(i<unc_len) v=row[rowpos++];
						else v=0; // padding

						if(c->compression==CMPR_RLE4) {
							if(i%2==0)
								c->mem[curpos] = v<<4;
							else
								c->mem[curpos++] |= v;
						}
						else {
							c->mem[curpos++] = v;
						}
					}
					continue;
				}
			}

			if((int)rowpos >= pixels_per_row) break;

			if(c->rletrns && row[rowpos]==0) break;

			// Write a compressed segment
			c->mem[curpos++] = run_lens[rowpos] + (unsigned char)(c->bad_rle?1:0);

			if(c->compression==CMPR_RLE4) {
				c->mem[curpos] = row[rowpos]<<4;
				if(run_lens[rowpos]>=2)
					c->mem[curpos] |= row[rowpos+1];
			}
			else {
				c->mem[curpos] = row[rowpos];
			}
			curpos++;
			rowpos += run_lens[rowpos];
		}

		// Write EOL (0 0) or EOBMP (0 1) marker.
		c->mem[curpos++] = 0;
		c->mem[curpos++] = (j==c->h-1) ? 1 : 0;
	}
	if (c->cut_rle) {
		c->mem[curpos++] = 0;
		c->mem[curpos++] = 1;
	}

	c->bitssize = curpos - c->bitsoffset;
	c->mem_used = c->bitsoffset + c->bitssize;
	retval = 1;

done:
	free(row);
	free(run_lens);
	return retval;
}

static int write_bits_fromfile(struct context *c, const char *fn)
{
	int retval = 0;
	FILE *f = NULL;

	f=fopen(fn,"rb");
	if(!f) goto done;

	c->bitssize = fread(&c->mem[c->bitsoffset], 1, 100000-c->bitsoffset, f);
	if(c->bitssize<1) goto done;
	c->mem_used = c->bitsoffset + c->bitssize;

	retval = 1;
done:
	if(f) fclose(f);
	return retval;
}

static int write_bits(struct context *c)
{
	int i,j;
	struct color_f clr;

	c->rowsize = (((c->w * c->bpp)+31)/32)*4;
	c->bitssize = c->rowsize*c->h;

	c->mem_used = c->bitsoffset + c->bitssize;

	for(j=0;j<c->h;j++) {
		for(i=0;i<c->w;i++) {
			get_pixel_color(c, i, c->halfheight ? j*2 : j, &clr);
			set_pixel(c, i, j, &clr);
		}
	}
	return 1;
}

static int write_profile(struct context *c, const char *fn, int gap)
{
	int retval = 0;
	FILE *f = NULL;

	f=fopen(fn,"rb");
	if(!f) goto done;

	// The "+ gap" leaves a gap of unused bytes between the bits and the
	// profile, just to be difficult.
	c->profile_offset = c->bitsoffset + c->bitssize + gap;

	c->profile_size = fread(&c->mem[c->profile_offset], 1, 100000-c->profile_offset, f);
	if(c->profile_size<1) goto done;
	c->mem_used = c->profile_offset + c->profile_size;

	retval = 1;
done:
	if(f) fclose(f);
	return retval;
}

static int write_lprofile(struct context *c)
{
	// Filenames are always encoded in Windows-1252.
	// 0x95=bullet; 0xeb="e" with a diaeresis
	static const char prof_fn[] = "C:\\temp\\test\x95\xeb.icc";

	c->profile_offset = c->bitsoffset + c->bitssize + 10;
	c->profile_size = 1+strlen(prof_fn);
	memcpy(&c->mem[c->profile_offset], prof_fn, c->profile_size);
	c->mem_used = c->profile_offset + c->profile_size;
	return 1;
}

static void write_bitfields(struct context *c)
{
	size_t offs;
	if(c->bitfieldssize!=12 && c->bitfieldssize!=16) return;
	offs = 14+c->headersize;
	set_uint32(c,offs  ,c->bf[I_R]);
	set_uint32(c,offs+4,c->bf[I_G]);
	set_uint32(c,offs+8,c->bf[I_B]);
	if(c->bitfieldssize==16) {
		set_uint32(c,offs+12,c->bf[I_A]);
	}
}

static void write_palette(struct context *c)
{
	size_t offs;
	int i, ii;
	int r,g,b;
	int bppe; // bytes per palette entry

	offs = 14+c->headersize+c->bitfieldssize;
	bppe = (c->headersize<=12) ? 3 : 4;

	if(c->bpp==8) {
		if(c->palette_reserve) {
			c->mem[offs+2] = 128;
			c->mem[offs+1] = 0;
			c->mem[offs+0] = 255;
		}

		if(c->pal_gs) {
			// Grayscale palette
			for(i=c->palette_reserve;i<c->pal_entries;i++) {
				ii = i-c->palette_reserve;
				if(i>=252+c->palette_reserve) continue;

				c->mem[offs+bppe*i+2] = quantize(ii/(double)(c->pal_entries - c->palette_reserve - 1), 256, 0, 0, 0, 0, 0);
				c->mem[offs+bppe*i+1] = quantize(ii/(double)(c->pal_entries - c->palette_reserve - 1), 256, 0, 0, 0, 0, 0);
				c->mem[offs+bppe*i+0] = quantize(ii/(double)(c->pal_entries - c->palette_reserve - 1), 256, 0, 0, 0, 0, 0);
			}
		}
		else {
			// R6G7B6 palette
			// Entry for a given (R,G,B) is R + G*6 + B*42
			for(i=c->palette_reserve;i<c->pal_entries;i++) {
				ii = i-c->palette_reserve;
				if(i>=252+c->palette_reserve) continue;
				r = ii%6;
				g = (ii%42)/6;
				b = ii/42;
				c->mem[offs+bppe*i+2] = quantize(((double)r)/5.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+bppe*i+1] = quantize(((double)g)/6.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+bppe*i+0] = quantize(((double)b)/5.0, 256, 0, 0, 0, 0, 0);
			}
		}
	}
	else if(c->bpp==4) {
		if(c->palette_reserve) {
			c->mem[offs+2] = 128;
			c->mem[offs+1] = 0;
			c->mem[offs+0] = 255;
		}

		if(c->pal_gs) {
			// Grayscale palette
			for(i=c->palette_reserve;i<c->pal_entries;i++) {
				ii = i-c->palette_reserve;
				r = quantize(ii/(double)(c->pal_entries - c->palette_reserve - 1),
					256, 0, 0, 0, 0, 0);
				c->mem[offs+bppe*i+2] = r;
				c->mem[offs+bppe*i+1] = r;
				c->mem[offs+bppe*i+0] = r;
			}
		}
		else {
			for(i=c->palette_reserve;i<c->pal_entries;i++) {
				ii = i-c->palette_reserve;
				r = ii%2;
				g = (ii%6)/2;
				b = ii/6;
				c->mem[offs+4*i+2] = quantize(((double)r)/1.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+4*i+1] = quantize(((double)g)/2.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+4*i+0] = quantize(((double)b)/1.0, 256, 0, 0, 0, 0, 0);
			}
		}
	}
	else if(c->bpp==2) {
		if(c->pal_gs) {
			for(i=0;i<4;i++) {
				// A 4-shade grayscale palette
				c->mem[offs+4*i+2] = 85*i;
				c->mem[offs+4*i+1] = 85*i;
				c->mem[offs+4*i+0] = 85*i;
			}
		}
		else {
			for(i=0;i<4;i++) {
				r = i%2;
				g = (i == 3) ? 1 : 0;
				b = i/2;
				c->mem[offs+4*i+2] = quantize(((double)r)/1.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+4*i+1] = quantize(((double)g)/1.0, 256, 0, 0, 0, 0, 0);
				c->mem[offs+4*i+0] = quantize(((double)b)/1.0, 256, 0, 0, 0, 0, 0);
			}
		}
	}
	else if(c->bpp==1) {
		if(c->pal_entries==2) {
			if(c->pal_wb) {
				c->mem[offs+4*0+2] = 255;
				c->mem[offs+4*0+1] = 255;
				c->mem[offs+4*0+0] = 255;
			}
			else if(c->pal_bg) {
				c->mem[offs+4*0+2] = 64;
				c->mem[offs+4*0+1] = 64;
				c->mem[offs+4*0+0] = 255;
				c->mem[offs+4*1+2] = 64;
				c->mem[offs+4*1+1] = 255;
				c->mem[offs+4*1+0] = 64;
			}
			else {
				c->mem[offs+4*1+2] = 255;
				c->mem[offs+4*1+1] = 255;
				c->mem[offs+4*1+0] = 255;
			}
		}
		else { // assuming c->pal_p1
			c->mem[offs+4*0+2] = 64;
			c->mem[offs+4*0+1] = 64;
			c->mem[offs+4*0+0] = 255;
		}
	}
	else if(c->bpp>8) {
		// Write a 'suggested' palette.
		for(i=0;i<c->pal_entries;i++) {
			if(i<=255) {
				c->mem[offs+4*i+2] = (unsigned char)i;
				c->mem[offs+4*i+1] = (unsigned char)i;
				c->mem[offs+4*i+0] = (unsigned char)i;
			}
		}
	}
}

static void write_fileheader(struct context *c)
{
	c->mem[0]='B';
	c->mem[1]='M';
	if(c->bad_bfSize)
		set_int32(c,2,0x7ddddddd);
	else if(c->cbsize_flag)
		set_int32(c,2,14+c->headersize);
	else
		set_int32(c,2,(int)c->mem_used);
	set_int32(c,10,c->bitsoffset);
}

static void write_bitmapcoreheader(struct context *c)
{
	set_int32(c,14+0,c->headersize);
	set_int16(c,14+4,c->w);
	set_int16(c,14+6,c->h);
	set_int16(c,14+8,1); // planes
	set_int16(c,14+10,c->bpp);
}

static unsigned int fixed_2_30(double x)
{
	return (unsigned int)(0.5 + x*1073741824.0);
}

static unsigned int fixed_16_16(double x)
{
	return (unsigned int)(0.5 + x*65536.0);
}

static void write_bitmapinfoheader(struct context *c)
{
	double gamma;

	set_int32(c,14+0,c->headersize);
	set_int32(c,14+4,(c->bad_width) ? -c->w : c->w); // biWidth
	set_int32(c,14+8,(c->topdown) ? -c->h : c->h);
	if(c->bad_reallybig) {
		set_int32(c,14+4,3000000);
		set_int32(c,14+8,2000000);
	}
	set_int16(c,14+12,(c->bad_planes) ? 30000 : 1); // biPlanes
	set_int16(c,14+14,(c->bad_bitcount) ? 30000 : c->bpp); // biBitCount

	if(c->headersize>=40) {
		set_int32(c,14+16,c->compression);
		if(c->zero_biSizeImage)
			set_int32(c,14+20,0);
		else if(c->bad_biSizeImage)
			set_int32(c,14+20,0x7eeeeeee);
		else
			set_int32(c,14+20,c->bitssize);

		set_int32(c,14+24,c->xpelspermeter);
		set_int32(c,14+28,c->ypelspermeter);
		set_int32(c,14+32,(c->bad_palettesize) ? 0x12341234 : c->clr_used); // biClrUsed
		set_int32(c,14+36,0); // biClrImportant
	}
	if(c->headersize>=52 && c->headersize!=64) {
		if(c->compression==3) {
			set_uint32(c,14+40,c->bf[I_R]);
			set_uint32(c,14+44,c->bf[I_G]);
			set_uint32(c,14+48,c->bf[I_B]);
		}
	}
	if(c->headersize>=56 && c->headersize!=64) {
		if(c->compression==3) {
			set_uint32(c,14+52,c->bf[I_A]);
		}
	}
	if(c->headersize>=108) {

		if(c->headersize==108) {
			// Modern documentation lists LCS_CALIBRATED_RGB as the only legal
			// CSType for v4 bitmaps.
			set_uint32(c,14+56,0); // CSType = LCS_CALIBRATED_RGB

			// Chromaticity endpoints.
			// I don't know much about what should go here. These are the
			// chromaticities for sRGB.
			// These values are in 2.30 fixed-point format.
			set_uint32(c,14+60, fixed_2_30(0.6400)); // red-x
			set_uint32(c,14+64, fixed_2_30(0.3300)); // red-y
			set_uint32(c,14+68, fixed_2_30(0.0300)); // red-z
			set_uint32(c,14+72, fixed_2_30(0.3000)); // green-x
			set_uint32(c,14+76, fixed_2_30(0.6000)); // green-y
			set_uint32(c,14+80, fixed_2_30(0.1000)); // green-z
			set_uint32(c,14+84, fixed_2_30(0.1500)); // blue-x
			set_uint32(c,14+88, fixed_2_30(0.0600)); // blue-y
			set_uint32(c,14+92, fixed_2_30(0.7900)); // blue-z

			// I'm not sure if this is supposed to be the "image file gamma", like
			// 1.0/2.2, or the "display gamma", like 2.2. "Image file gamma" is my
			// best guess.
			gamma = 1.0/2.2;
			// These values are in 16.16 fixed-point format.
			set_uint32(c,14+ 96, fixed_16_16(gamma)); // bV4GammaRed
			set_uint32(c,14+100, fixed_16_16(gamma)); // bV4GammaGreen
			set_uint32(c,14+104, fixed_16_16(gamma)); // bV4GammaBlue
		}
		else {
			if(c->embed_profile) {
				set_uint32(c,14+56,0x4d424544); // CSType = PROFILE_EMBEDDED
			}
			else if(c->link_profile) {
				set_uint32(c,14+56,0x4c494e4b); // CSType = PROFILE_LINKED
			}
			else {
				set_uint32(c,14+56,0x73524742); // CSType = sRGB
			}
		}
	}
	if(c->headersize>=124) {
		set_uint32(c,14+108,4); // Rendering intent = Perceptual
		if(c->embed_profile || c->link_profile) {
			set_uint32(c,14+112,c->profile_offset-14);
			set_uint32(c,14+116,c->profile_size);
		}
	}
}

static int make_bmp(struct context *c)
{
	int ret;

	write_bitfields(c);
	write_palette(c);
	if(c->compression==CMPR_RLE4 || c->compression==CMPR_RLE8)
		ret = write_bits_rle(c);
	else if(c->compression==CMPR_JPEG && c->headersize>40)
		ret = write_bits_fromfile(c,"data/image.jpg");
	else if(c->compression==CMPR_PNG)
		ret = write_bits_fromfile(c,"data/image.png");
	else
		ret = write_bits(c);
	if(!ret) {
		fprintf(stderr,"Failed to generate image for %s\n",c->filename);
		return 0;
	}
	if(c->embed_profile) {
		if(c->profile_to_embed==1) {
			write_profile(c, "data/swap-r-g.icc", 0);
		}
		else {
			write_profile(c, "data/srgb.icc", 20);
		}
	}
	else if(c->link_profile) {
		write_lprofile(c);
	}
	if(c->headersize<=12)
		write_bitmapcoreheader(c);
	else
		write_bitmapinfoheader(c);
	write_fileheader(c);
	return 1;
}

static int write_image_file(struct context *c)
{
	FILE *f;

	fprintf(stderr,"Writing %s\n",c->filename);
	f = fopen(c->filename,"wb");
	if(!f) {
		fprintf(stderr,"Can't write %s\n",c->filename);
		return 0;
	}
	if(c->bad_eof) {
		fwrite(c->mem,1,273,f);
	}
	else {
		fwrite(c->mem,1,c->mem_used,f);
	}
	fclose(f);
	return 1;
}

static int make_bmp_file(struct context *c)
{
	if(!make_bmp(c)) return 0;
	if(!write_image_file(c)) return 0;
	return 1;
}

static void set_calculated_fields(struct context *c)
{

	if(c->bpp==8 && c->pal_entries!=256) {
		c->clr_used = c->pal_entries;
	}
	else if(c->bpp==4 && c->pal_entries!=16) {
		c->clr_used = c->pal_entries;
	}
	else if(c->bpp==1 && c->pal_entries!=2) {
		c->clr_used = c->pal_entries;
	}
	else {
		c->clr_used = c->pal_entries;
	}

	if(c->headersize<=12) {
		c->clr_used = c->pal_entries;
		c->palettesize = c->pal_entries*3;
	}
	else {
		c->palettesize = c->pal_entries*4;
	}

	c->bitsoffset = 14 + c->headersize + c->bitfieldssize + c->palettesize + c->extrabytessize;

	if(c->rletrns || (c->bf[I_A] && c->nbits[I_A]==1)) {
		c->trnstype = 1; // binary transparency
	}
	else if(c->bf[I_A]) {
		c->trnstype = 2; // alpha transparency
	}
	else {
		c->trnstype = 0;
	}
}

static void defaultbmp(struct global_context *glctx, struct context *c)
{
	int z;

	memset(glctx->mem,0,BMP_MAX_SIZE);
	memset(c, 0, sizeof(struct context));

	// Copy ->mem pointer, so we don't need glctx from here on.
	c->mem = glctx->mem;
	c->mem_used = 0;

#ifdef SMALL_IMAGES
	c->w = 31;
	c->h = 32;
#else
	c->w = 127;
	c->h = 64;
#endif
	c->bpp = 8;
	c->pal_entries = 252;
	c->headersize = 40;
	c->filename = "noname.bmp";
	c->compression = 0; // BI_RGB
	c->xpelspermeter = 2835; // = about 72dpi
	c->ypelspermeter = 2835;

	for(z=0; z<4; z++)
		c->dither[z] = -1;

	set_calculated_fields(c);
}

static int my_mkdir(const char *pathname)
{
#ifdef _WIN32
	return _mkdir(pathname);
#else
	return mkdir(pathname, 0755);
#endif
}

static int run(struct global_context *glctx, struct context *c)
{
	int retval = 0;

	my_mkdir("g");
	my_mkdir("q");
	my_mkdir("b");

	defaultbmp(glctx, c);
	c->filename = "g/pal8.bmp";
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8gs.bmp";
	c->pal_gs = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8os2.bmp";
	c->headersize = 12;
	c->pal_entries = 256;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2-sz.bmp";
	c->headersize = 12;
	c->pal_entries = 256;
	c->cbsize_flag = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2sp.bmp";
	c->headersize = 12;
	c->pal_entries = 252;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2v2-16.bmp";
	c->headersize = 16;
	c->pal_entries = 256;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2v2.bmp";
	c->headersize = 64;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2v2-40sz.bmp";
	c->headersize = 40;
	c->cbsize_flag = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8os2v2-sz.bmp";
	c->headersize = 64;
	c->cbsize_flag = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8v4.bmp";
	c->headersize = 108;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8v5.bmp";
	c->headersize = 124;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8w124.bmp";
#ifdef SMALL_IMAGES
	c->w = 28; c->h = 29;
#else
	c->w = 124; c->h = 61;
#endif
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8w125.bmp";
#ifdef SMALL_IMAGES
	c->w = 29; c->h = 30;
#else
	c->w = 125; c->h = 62;
#endif
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8w126.bmp";
#ifdef SMALL_IMAGES
	c->w = 30; c->h = 31;
#else
	c->w = 126; c->h = 63;
#endif
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8-0.bmp";
	c->pal_entries = 256;
	c->xpelspermeter = 0;
	c->ypelspermeter = 0;
	c->zero_biSizeImage = 1;
	set_calculated_fields(c);
	c->clr_used = 0;
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8offs.bmp";
	c->extrabytessize = 100;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8oversizepal.bmp";
	c->pal_entries = 300;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/pal8badindex.bmp";
	c->pal_entries = 101;
	c->palette_reserve = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badpalettesize.bmp";
	c->bad_palettesize = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8topdown.bmp";
	c->topdown = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8nonsquare.bmp";
	c->halfheight = 1;
	c->ypelspermeter = 1417;
#ifdef SMALL_IMAGES
	c->h = 16;
#else
	c->h = 32;
#endif
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal8rle.bmp";
	c->compression = CMPR_RLE8;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8rlecut.bmp";
	c->compression = CMPR_RLE8;
	c->rletrns = 1;
	c->pal_entries = 253;
	c->palette_reserve = 1;
	c->cut_rle = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrle.bmp";
	c->compression = CMPR_RLE8;
	c->rletrns = 1;
	c->pal_entries = 253;
	c->palette_reserve = 1;
	c->bad_rle = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrlebis.bmp";
	c->compression = CMPR_RLE8;
	c->rletrns = 1;
	c->pal_entries = 253;
	c->palette_reserve = 1;
	c->bad_rle_bis = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrleter.bmp";
	c->compression = CMPR_RLE8;
	c->rletrns = 1;
	c->pal_entries = 253;
	c->palette_reserve = 1;
	c->bad_rle_bis = 1;
	c->bad_rle_ter = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrle4.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->rletrns = 1;
	c->pal_entries = 13;
	c->palette_reserve = 1;
	c->bad_rle = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrle4bis.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->rletrns = 1;
	c->pal_entries = 13;
	c->palette_reserve = 1;
	c->bad_rle_bis = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badrle4ter.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->rletrns = 1;
	c->pal_entries = 13;
	c->palette_reserve = 1;
	c->bad_rle_bis = 1;
	c->bad_rle_ter = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/rletopdown.bmp";
	c->topdown = 1;
	c->compression = CMPR_RLE8;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal8rletrns.bmp";
	c->compression = CMPR_RLE8;
	c->rletrns = 1;
	c->pal_entries = 253;
	c->palette_reserve = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal4.bmp";
	c->bpp = 4;
	c->pal_entries = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal4gs.bmp";
	c->bpp = 4;
	c->pal_entries = 12;
	c->pal_gs = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal4rle.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->pal_entries = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal4rlecut.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->rletrns = 1;
	c->pal_entries = 13;
	c->palette_reserve = 1;
	c->cut_rle = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal4rletrns.bmp";
	c->bpp = 4;
	c->compression = CMPR_RLE4;
	c->rletrns = 1;
	c->pal_entries = 13;
	c->palette_reserve = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal1.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal1wb.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->pal_wb = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/pal1bg.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->pal_bg = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal1p1.bmp";
	c->bpp = 1;
	c->pal_entries = 1;
	c->pal_p1 = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badbitssize.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_biSizeImage = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badfilesize.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_bfSize = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/shortfile.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_eof = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badwidth.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_width = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/reallybig.bmp";
	c->bpp = 24;
	c->pal_entries = 0;
	c->bad_reallybig = 1;
	c->bad_biSizeImage = 1;
	c->bad_bfSize = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badbitcount.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_bitcount = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badplanes.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->bad_planes = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/badheadersize.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->headersize = 66;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/baddens1.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->xpelspermeter = 30000000;
	c->ypelspermeter = 3;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/baddens2.bmp";
	c->bpp = 1;
	c->pal_entries = 2;
	c->xpelspermeter = 3;
	c->ypelspermeter = 30000000;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal2.bmp";
	c->bpp = 2;
	c->pal_entries = 4;
	c->pal_gs = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/pal2color.bmp";
	c->bpp = 2;
	c->pal_entries = 4;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb16.bmp";
	c->bpp = 16;
	c->nbits[I_R] = c->nbits[I_G] = c->nbits[I_B] = 5;
	c->pal_entries = 0;
	c->nbits[I_R] = 5; c->bf_shift[I_R] = 10;
	c->nbits[I_G] = 5; c->bf_shift[I_G] = 5;
	c->nbits[I_B] = 5; c->bf_shift[I_B] = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb16-565.bmp";
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x0000f800; c->nbits[I_R] = 5; c->bf_shift[I_R] = 11;
	c->bf[I_G] = 0x000007e0; c->nbits[I_G] = 6; c->bf_shift[I_G] = 5;
	c->bf[I_B] = 0x0000001f; c->nbits[I_B] = 5; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "b/rgb16-880.bmp";
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x0000ff00; c->nbits[I_R] = 8; c->bf_shift[I_R] = 8;
	c->bf[I_G] = 0x000000ff; c->nbits[I_G] = 8; c->bf_shift[I_G] = 0;
	c->bf[I_B] = 0x00000000; c->nbits[I_B] = 0; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb16-565pal.bmp";
	c->bpp = 16;
	c->pal_entries = 256;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x0000f800; c->nbits[I_R] = 5; c->bf_shift[I_R] = 11;
	c->bf[I_G] = 0x000007e0; c->nbits[I_G] = 6; c->bf_shift[I_G] = 5;
	c->bf[I_B] = 0x0000001f; c->nbits[I_B] = 5; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb16faketrns.bmp";
	c->bpp = 16;
	c->nbits[I_R] = c->nbits[I_G] = c->nbits[I_B] = 5;
	c->pal_entries = 0;
	c->fakealpha = 1;
	c->nbits[I_R] = 5; c->bf_shift[I_R] = 10;
	c->nbits[I_G] = 5; c->bf_shift[I_G] = 5;
	c->nbits[I_B] = 5; c->bf_shift[I_B] = 0;
	c->nbits[I_A] = 1; c->bf_shift[I_A] = 15;
	c->dither[I_A] = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba16-4444.bmp";
	c->headersize = 124;
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x00000f00; c->nbits[I_R] = 4; c->bf_shift[I_R] = 8;
	c->bf[I_G] = 0x000000f0; c->nbits[I_G] = 4; c->bf_shift[I_G] = 4;
	c->bf[I_B] = 0x0000000f; c->nbits[I_B] = 4; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0x0000f000; c->nbits[I_A] = 4; c->bf_shift[I_A] = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba16-5551.bmp";
	c->headersize = 124;
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x00007c00; c->nbits[I_R] = 5; c->bf_shift[I_R] = 10;
	c->bf[I_G] = 0x000003e0; c->nbits[I_G] = 5; c->bf_shift[I_G] = 5;
	c->bf[I_B] = 0x0000001f; c->nbits[I_B] = 5; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0x00008000; c->nbits[I_A] = 1; c->bf_shift[I_A] = 15;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba16-1924.bmp";
	c->headersize = 124;
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x00000800; c->nbits[I_R] =  1; c->bf_shift[I_R] = 11;
	c->bf[I_G] = 0x000001ff; c->nbits[I_G] =  9; c->bf_shift[I_G] =  0;
	c->bf[I_B] = 0x00000600; c->nbits[I_B] =  2; c->bf_shift[I_B] =  9;
	c->bf[I_A] = 0x0000f000; c->nbits[I_A] =  4; c->bf_shift[I_A] = 12;
	c->dither[I_R] = 1;
	c->dither[I_G] = 0;
	c->dither[I_B] = 1;
	c->dither[I_A] = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb16-231.bmp";
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x00000030; c->nbits[I_R] = 2; c->bf_shift[I_R] = 4;
	c->bf[I_G] = 0x0000000e; c->nbits[I_G] = 3; c->bf_shift[I_G] = 1;
	c->bf[I_B] = 0x00000001; c->nbits[I_B] = 1; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	c->dither[I_R] = c->dither[I_G] = c->dither[I_B] = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb16-3103.bmp";
	c->bpp = 16;
	c->pal_entries = 0;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x00000038; c->nbits[I_R] =  3; c->bf_shift[I_R] = 3;
	c->bf[I_G] = 0x0000ffc0; c->nbits[I_G] = 10; c->bf_shift[I_G] = 6;
	c->bf[I_B] = 0x00000007; c->nbits[I_B] =  3; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	c->dither[I_R] = 1;
	c->dither[I_G] = 0;
	c->dither[I_B] = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb24.bmp";
	c->bpp = 24;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24prof.bmp";
	c->headersize = 124;
	c->bpp = 24;
	c->pal_entries = 0;
	c->embed_profile = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24prof2.bmp";
	c->headersize = 124;
	c->bpp = 24;
	c->pal_entries = 0;
	c->embed_profile = 1;
	c->profile_to_embed = 1;
	c->swaprg = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24lprof.bmp";
	c->headersize = 124;
	c->bpp = 24;
	c->pal_entries = 0;
	c->link_profile = 1;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb24pal.bmp";
	c->bpp = 24;
	c->pal_entries = 256;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24largepal.bmp";
	c->bpp = 24;
	c->pal_entries = 300;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb32.bmp";
	c->bpp = 32;
	c->pal_entries = 0;
	c->nbits[I_R] = 8; c->bf_shift[I_R] = 16;
	c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "g/rgb32bf.bmp";
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->pal_entries = 0;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x00000ff0; c->nbits[I_G] = 8; c->bf_shift[I_G] = 4;
	c->bf[I_B] = 0x00ff0000; c->nbits[I_B] = 8; c->bf_shift[I_B] = 16;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb32fakealpha.bmp";
	c->bpp = 32;
	c->pal_entries = 0;
	c->fakealpha = 1;
	c->nbits[I_R] = 8; c->bf_shift[I_R] = 16;
	c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	c->nbits[I_A] = 8; c->bf_shift[I_A] = 24;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb32-111110.bmp";
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->pal_entries = 0;
	c->bf[I_R] = 0xffe00000; c->nbits[I_R] = 11; c->bf_shift[I_R] = 21;
	c->bf[I_G] = 0x001ffc00; c->nbits[I_G] = 11; c->bf_shift[I_G] = 10;
	c->bf[I_B] = 0x000003ff; c->nbits[I_B] = 10; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb32-7187.bmp";
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->pal_entries = 0;
	c->bf[I_R] = 0xfe000000; c->nbits[I_R] = 7; c->bf_shift[I_R] = 25;
	c->bf[I_G] = 0x01ffff80; c->nbits[I_G] = 18; c->bf_shift[I_G] = 7;
	c->bf[I_B] = 0x0000007f; c->nbits[I_B] = 7; c->bf_shift[I_B] = 0;
	c->bitfieldssize = 12;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32.bmp";
	c->headersize = 124;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x0000ff00; c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->bf[I_B] = 0x000000ff; c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0x00ff0000; c->nbits[I_A] = 8; c->bf_shift[I_A] = 16;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

    defaultbmp(glctx, c);
	c->filename = "q/rgb32bf-xbgr.bmp";
	c->headersize = 124;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x00ff0000; c->nbits[I_G] = 8; c->bf_shift[I_G] = 16;
	c->bf[I_B] = 0x0000ff00; c->nbits[I_B] = 8; c->bf_shift[I_B] = 8;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32-1010102.bmp";
	c->headersize = 124;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x3ff00000; c->nbits[I_R] = 10; c->bf_shift[I_R] = 20;
	c->bf[I_G] = 0x000ffc00; c->nbits[I_G] = 10; c->bf_shift[I_G] = 10;
	c->bf[I_B] = 0x000003ff; c->nbits[I_B] = 10; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0xc0000000; c->nbits[I_A] = 2;  c->bf_shift[I_A] = 30;
	c->dither[I_A] = 1;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32-81284.bmp";
	c->headersize = 124;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x0000ff00; c->nbits[I_R] =  8; c->bf_shift[I_R] =  8;
	c->bf[I_G] = 0x0fff0000; c->nbits[I_G] = 12; c->bf_shift[I_G] = 16;
	c->bf[I_B] = 0x000000ff; c->nbits[I_B] =  8; c->bf_shift[I_B] =  0;
	c->bf[I_A] = 0xf0000000; c->nbits[I_A] =  4; c->bf_shift[I_A] = 28;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32-61754.bmp";
	c->headersize = 124;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0x0fc00000; c->nbits[I_R] =  6; c->bf_shift[I_R] = 22;
	c->bf[I_G] = 0x003fffe0; c->nbits[I_G] = 17; c->bf_shift[I_G] =  5;
	c->bf[I_B] = 0x0000001f; c->nbits[I_B] =  5; c->bf_shift[I_B] =  0;
	c->bf[I_A] = 0xf0000000; c->nbits[I_A] =  4; c->bf_shift[I_A] = 28;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb32h52.bmp";
	c->headersize = 52;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x0000ff00; c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->bf[I_B] = 0x000000ff; c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32h56.bmp";
	c->headersize = 56;
	c->bpp = 32;
	c->compression = BI_BITFIELDS;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x0000ff00; c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->bf[I_B] = 0x000000ff; c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0x00ff0000; c->nbits[I_A] = 8; c->bf_shift[I_A] = 16;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgba32abf.bmp";
	c->bpp = 32;
	c->compression = BI_ALPHABITFIELDS;
	c->bf[I_R] = 0xff000000; c->nbits[I_R] = 8; c->bf_shift[I_R] = 24;
	c->bf[I_G] = 0x0000ff00; c->nbits[I_G] = 8; c->bf_shift[I_G] = 8;
	c->bf[I_B] = 0x000000ff; c->nbits[I_B] = 8; c->bf_shift[I_B] = 0;
	c->bf[I_A] = 0x00ff0000; c->nbits[I_A] = 8; c->bf_shift[I_A] = 16;
	c->bitfieldssize = 16;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24jpeg.bmp";
	c->headersize = 124;
	c->bpp = 0;
	c->compression = CMPR_JPEG;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	defaultbmp(glctx, c);
	c->filename = "q/rgb24png.bmp";
	c->headersize = 124;
	c->bpp = 0;
	c->compression = CMPR_PNG;
	c->pal_entries = 0;
	set_calculated_fields(c);
	if(!make_bmp_file(c)) goto done;

	retval = 1;
done:
	return retval;
}

int main(int argc, char **argv)
{
	struct global_context glctx;
	struct context c;
	int ret = 0;

	glctx.mem = malloc(BMP_MAX_SIZE);
	if(!glctx.mem) goto done;

	ret = run(&glctx, &c);

done:
	free(glctx.mem);
	return ret ? 0 : 1;
}
